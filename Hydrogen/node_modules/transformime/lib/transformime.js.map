{"version":3,"sources":["../src/transformime.js"],"names":[],"mappings":"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","file":"transformime.js","sourcesContent":["'use strict'\n\nimport { TextTransform } from './text.transform'\nimport { ImageTransform } from './image.transform'\nimport { HTMLTransform } from './html.transform'\nimport { SVGTransform } from './svg.transform'\nimport { PDFTransform } from './pdf.transform'\nimport { ScriptTransform } from './script.transform'\nimport { LaTeXTransform } from './latex.transform'\nimport { MarkdownTransform } from './commonmark.transform'\n/**\n * Transforms mimetypes into HTMLElements\n */\nclass Transformime {\n\n  /**\n   * Public constructor\n   * @param  {function[]} transformers - list of transformers, in reverse priority order.\n   */\n  constructor (transformers) {\n    // Initialize instance variables.\n    this.transformers = []\n    this.push(TextTransform)\n    this.push(ImageTransform)\n    this.push(SVGTransform)\n    this.push(HTMLTransform)\n    this.push(PDFTransform)\n    this.push(ScriptTransform)\n    this.push(MarkdownTransform)\n    this.push(LaTeXTransform)\n    if (transformers) transformers.forEach((transformer) => { this.push(transformer) })\n  }\n  /**\n   * Transforms a mime bundle, using the richest available representation,\n   * into an HTMLElement.\n   * @param  {any}      bundle - {mimetype1: data1, mimetype2: data2, ...}\n   * @param  {Document} document - Any of window.document, iframe.contentDocument\n   * @return {Promise<{mimetype: string, el: HTMLElement}>}\n   */\n  transform (bundle, document) {\n    if (this.transformers.length <= 0) {\n      // Empty transformers\n      return Promise.reject(new Error('No transformers configured'))\n    }\n\n    if (Object.keys(bundle).length <= 0) {\n      return Promise.reject(new Error('MIME Bundle empty'))\n    }\n\n    let richMimetype\n    let richTransformer\n\n    // Choose the last transformer as the most rich\n    for (let transformer of this.transformers) {\n      if (transformer.mimetype) {\n        // Make sure the transformer's mimetype is in array format.\n        let transformer_mimetypes = transformer.mimetype\n        if (!Array.isArray(transformer_mimetypes)) {\n          transformer_mimetypes = [transformer_mimetypes]\n        }\n\n        for (let transformer_mimetype of transformer_mimetypes) {\n          if (transformer_mimetype in bundle) {\n            richMimetype = transformer_mimetype\n            richTransformer = transformer\n          }\n        }\n      }\n    }\n\n    if (richMimetype && richTransformer) {\n      // Don't assume the transformation will return a promise.  Also\n      // don't assume the transformation will succeed.\n      try {\n        return Promise.resolve(richTransformer.call(richTransformer,\n          richMimetype, bundle[richMimetype], document)).then(el => {\n            return { mimetype: richMimetype, el: el }\n          })\n      } catch (e) {\n        return Promise.reject(e)\n      }\n    } else {\n      return Promise.reject(new Error('Transformer(s) for ' + Object.keys(bundle).join(', ') + ' not found.'))\n    }\n  }\n\n  /**\n   * Deletes all transformers by mimetype.\n   * @param {string|string[]} mimetype - mimetype the data type (e.g. text/plain, text/html, image/png)\n   */\n  del (mimetype) {\n    // Convert mimetype to an array.\n    let mimetypes = mimetype\n    if (!Array.isArray(mimetypes)) {\n      mimetypes = [mimetypes]\n    }\n\n    // Remove each mimetype.\n    for (mimetype of mimetypes) {\n      for (let i = 0; i < this.transformers.length; i++) {\n        var transformer = this.transformers[i]\n\n        // If the mimetype matches the one we want to remove, remove it.\n        if (mimetype === transformer.mimetype) {\n          this.transformers.splice(i, 1)\n          i--\n\n        // If the mimetype we want to remove is in the list of the\n        // mimetypes supported by the transformer, remove it from the list.\n        // If the transformer mimetype list is then empty, remove the\n        // transformer.\n        } else if (Array.isArray(transformer.mimetype) && mimetype in transformer.mimetype) {\n          if (transformer.mimetype.length === 1) {\n            this.transformers.splice(i, 1)\n            i--\n          } else {\n            transformer.mimetype.splice(transformer.mimetype.indexOf(mimetype), 1)\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets a transformer matching the mimetype\n   * @param {string} mimetype - the data type (e.g. text/plain, text/html, image/png)\n   * @return {function} Matching transformer\n   */\n  get (mimetype) {\n    // Loop through the transformers array in reverse.\n    for (let i = this.transformers.length - 1; i >= 0; i--) {\n      let transformer = this.transformers[i]\n\n      // Get an array of the mimetypes that the transformer supports.\n      let transformer_mimetypes = transformer.mimetype\n      if (!Array.isArray(transformer_mimetypes)) {\n        transformer_mimetypes = [transformer_mimetypes]\n      }\n\n      // Check if any of the mimetypes match the one we are looking for.\n      for (let transformer_mimetype of transformer_mimetypes) {\n        if (mimetype === transformer_mimetype) {\n          return transformer\n        }\n      }\n    }\n  }\n\n  /**\n   * Sets a transformer matching the mimetype\n   * @param {string|string[]} mimetype - the data type (e.g. text/plain, text/html, image/png)\n   * @param {function} transformer\n   * @return {function} inserted transformer function (may be different than arg)\n   */\n  set (mimetype, transformer) {\n    this.del(mimetype)\n    return this.push(transformer, mimetype)\n  }\n\n  /**\n   * Appends a transformer to the transformer list.\n   * @param  {function} transformer\n   * @param  {string|string[]} mimetype\n   * @return {function} inserted transformer function (may be different than arg)\n   */\n  push (transformer, mimetype) {\n    // If the mimetype specified is different than the mimetype of the\n    // transformer, make a copy of the transformer and set the new mimetype\n    // on the copy.\n    let transform = transformer\n    if (mimetype && transformer.mimetype !== mimetype) {\n      transform = this._proxy(transformer, mimetype)\n    }\n\n    // Verify a mimetype is set on the transformer.\n    if (!transform.mimetype) throw Error('Could not infer transformer mimetype')\n\n    this.transformers.push(transform)\n    return transform\n  }\n\n  /**\n   * Create a proxy to a transformer, using another mimetype.\n   * @param  {function} transformer\n   * @param  {string|string[]} mimetype\n   * @return {function} transformer\n   */\n  _proxy (transformer, mimetype) {\n    let transform = function (...args) { return transformer.call(this, ...args) }\n    transform.mimetype = mimetype\n    return transform\n  }\n}\n\n/**\n* Helper to create a function that transforms a MIME bundle into an HTMLElement\n* using the given document and list of transformers.\n* @param  {function[]} [transformers] List of transformers, in reverse priority order.\n* @param  {Document}   [doc]          E.g. window.document, iframe.contentDocument\n* @return {function}\n*/\nfunction createTransform (transformers, doc) {\n  const t = new Transformime(transformers)\n\n  if (!doc) {\n      doc = document\n  }\n\n  /**\n   * Transforms a MIME bundle into an HTMLElement.\n   * @param  {object} bundle {mimetype1: data1, mimetype2: data2, ...}\n   * @return {Promise<{mimetype: string, el: HTMLElement}>}\n   */\n  return function transform(bundle) {\n    return t.transform(bundle, doc)\n  }\n}\n\nexport {\n    Transformime,\n    TextTransform,\n    TextTransform as TextTransformer,\n    ImageTransform,\n    ImageTransform as ImageTransformer,\n    HTMLTransform,\n    HTMLTransform as HTMLTransformer,\n    SVGTransform,\n    SVGTransform as SVGTransform,\n    PDFTransform,\n    PDFTransform as PDFTransform,\n    ScriptTransform,\n    ScriptTransform as ScriptTransform,\n    LaTeXTransform,\n    LaTeXTransform as LaTeXTransform,\n    MarkdownTransform,\n    MarkdownTransform as MarkdownTransform,\n    createTransform\n};\n"]}